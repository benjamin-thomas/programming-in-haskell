{-# OPTIONS_GHC -Wall #-}

import Prelude hiding (mapM)
import Data.Char
    ( digitToInt
    , isDigit
    )

{-

The State Monad
===============

Or how to write a function that can manipulate some form of state that can be
changed over time.

-}


-- Let's assume our state is an integer value
type State = Int


{-

The most basic function for this type would be a State Transformer (ST), that
would take an input State, to produce an output State.

Since we may want to access another value (at the point of the computed State), we add and use an extra type parameter.

Before:
type ST = State -> State

After:
type ST a = State -> (a, State)


---

And because we can't make instances declarations with "type", we must use "newtype", with a constructor
type ST a = State -> (a, State)

Before:
type ST a = State -> (a, State)

After:
newtype ST a = MkST (State -> (a, State))
-}

newtype ST a = MkST (State -> (a, State))


{-
We define a helper function that extracts the wrapped function contained in
MkST.  Since this wrapped function takes State as argument, we also require it
and run this extracted function to get its result.

λ> app (MkST (\s -> (Data.Char.intToDigit s, s+1))) 10
('a',11)

λ> app (MkST (\s -> (Data.Char.intToDigit s, s+1))) 11
('b',12)

λ> app (MkST (\s -> (Data.Char.intToDigit s, s+1))) 12
('c',13)

-}
app :: ST a -> State -> (a, State)
app (MkST f) = f



-- Step 1 towards making this data structure a Monad instance is to define a Functor instance
instance Functor ST where
    fmap :: (a -> b) -> ST a -> ST b
    fmap f sta = MkST (\state -> let (a, state') = app sta state in (f a, state'))
    --fmap f (MkST ma) = MkST (\state -> let (a, state') = ma state in (f a, state'))
{-

λ> app (fmap succ (MkST (\s -> (Data.Char.intToDigit s, s+1)))) 10
('b',11)

-}


-- Step 2: we define Applicative
instance Applicative ST where
    pure :: a -> ST a
    pure a = MkST (\state -> (a, state))

    (<*>) :: ST (a -> b) -> ST a -> ST b
    (<*>) stf sta = MkST (\state ->
                            let
                                (f, state')  = app stf state
                                (a, state'') = app sta state'
                            in
                            (f a, state'')
                         )
{-
    (<*>) (MkST mf) (MkST ma) = MkST (\state ->
                                         let
                                             (f, state')  = mf state
                                             (a, state'') = ma state'
                                         in
                                         (f a, state'')
                                     )
-}

{-

λ> let x1 = pure 'A' :: ST Char
λ> let x2 = fmap succ x1
λ> app x2 99
('B',99)

---

λ> let x1 = pure 3 :: ST Int
λ> let x2 = pure 4 :: ST Int
λ> let x3 = (*) <$> x1 <*> x2
λ> app x3 0
(12,0)

---

λ> let x1 = pure 3 :: ST Int
λ> let x2 = pure 4 :: ST Int
λ> let x3 = pure (*) <*> x1 <*> x2
λ> app x3 0
(12,0)

-}


-- Step 3: now we can define a Monad instance
instance Monad ST where
    (>>=) :: ST a -> (a -> ST b) -> ST b
    --(>>=) (MkST ma) next = MkST (\state -> let (a, state') = ma state in app (next a) state')
    (>>=) sta next = MkST (\state -> let (a, state') = app sta state in app (next a) state')
{-
    (>>=) (MkST ma) next = MkST (\state ->
                                    let
                                        (a, state') = ma state
                                        (MkST mb)   = next a
                                    in mb state'
                                )
-}
{-

λ> app (MkST (\s -> (s, s + 1)) >>= \x -> MkST (\s -> (s, s + 1)) >>= \y -> pure (x + y)) 0
(1,2)

-}



-- RELABELLING TREES


data Tree a
    = Leaf a
    | Node (Tree a) (Tree a)
    deriving Show


tree :: Tree Char
tree =
    Node
        (Node
            (Leaf 'a')
            (Leaf 'b')
        )
        (Leaf 'c')


{-

λ> fst $ rlabel tree 0
Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)

-}
rlabel :: Tree a -> Int -> (Tree Int, Int)
rlabel (Leaf _) n   = (Leaf n, n+1)
rlabel (Node l r) n =
    let
        (l', n')  = rlabel l n
        (r', n'') = rlabel r n'
    in
    (Node l' r', n'')


{-

The definition for `rlabel` is complicated by the need to explicitly thread an
integer state through the computation

To obtain a simpler definition, we first note that the type:

Tree a -> Int -> (Tree Int, Int)

can be rewritten using the state transformer newtype:

Tree a -> ST (Tree Int)

where the state is the next fresh integer.

...
-}

{-
...

The next such integer can be generated by defining a state transformer that
simply returns the current state as its result, and the next integer as the new
state.

-}
fresh :: ST Int
fresh = MkST (\n -> (n, n+1))

{-

Using the fact that ST is an Applicative Functor, we can now define a new
version of the relabelling function that is written in applicative style.


λ> app (alabel tree) 0
(Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)


---

Here, the current state is on the left and the next state is on the right:
λ> app (Leaf <$> fresh) 0
(Leaf 0,1)

λ> app (Leaf <$> fresh) 1
(Leaf 1,2)

λ> app (Leaf <$> fresh) 2
(Leaf 2,3)


Again, here the current state is on the left and the next state is on the right:
λ> app (Node <$> alabel (Leaf 'A') <*> alabel (Leaf 'B')) 0
(Node (Leaf 0) (Leaf 1),2)

λ> app (pure Node <*> alabel (Leaf 'A') <*> alabel (Leaf 'B')) 0
(Node (Leaf 0) (Leaf 1),2)

-}
alabel :: Tree a -> ST (Tree Int)
alabel (Leaf _)   = Leaf <$> fresh
alabel (Node l r) = Node <$> alabel l <*> alabel r

{-

The result is identical:


λ> fst $ rlabel tree 0
Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)
λ> fst $ app (alabel tree) 0
Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)


But `alabel`'s implementation is much simpler than `rlabel`'s.

-}


{-

Given the fact that ST is also a monad, we can define an equivalent monadic
version of the relabelling function using `do` notation.

This function is equivalent, the only difference is that we have to name the intermediary arguments.


λ> fst $ rlabel tree 0
Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)

λ> fst $ app (alabel tree) 0
Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)

λ> fst $ app (mlabel tree) 0
Node (Node (Leaf 0) (Leaf 1)) (Leaf 2)

-}

mlabel :: Tree a -> ST (Tree Int)
mlabel (Leaf _)   = do
    n <- fresh
    return $ Leaf n

mlabel (Node l r) = do
    l' <- mlabel l
    r' <- mlabel r
    return $ Node l' r'


-- GENERIC FUNCTIONS

{-

A benefit of the Monad abstraction is the ability to define functions
compatible with any monad.

For instance, mapping...
-}

mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM _ []     = return []
mapM f (x:xs) = do
    y  <- f x
    ys <- mapM f xs
    return (y : ys)

{-

Notice that this is the `map` signature, except the function arg and the return
value have monadic return types.

To illustrate how it might be used, consider a function that converts a digit
character to its numeric value.

We can then apply it:


λ> mapM conv "1234"
Just [1,2,3,4]

λ> mapM conv "1a234"
Nothing

It's an "all or nothing" proposition though...

Compare with:

λ> map conv "1a234"
[Just 1,Nothing,Just 2,Just 3,Just 4]

λ> fmap conv "1a234"
[Just 1,Nothing,Just 2,Just 3,Just 4]
-}
conv :: Char -> Maybe Int
conv c
    | isDigit c = Just (digitToInt c)
    | otherwise = Nothing

{-

Since Monads enforce sequential flow + short-circuiting, we should stay in
Functor-land if we want to "accumulate errors".

Bad values on the left (think display something useful to the user):
λ> Data.Either.partitionEithers $ fmap convEither "1a2b34"
("ab",[1,2,3,4])

Comparatively, mapM stops on the first error:
λ> mapM convEither "1a2b34"
Left 'a'
-}
convEither :: Char -> Either Char Int
convEither c
    | isDigit c = Right (digitToInt c)
    | otherwise = Left c


{-

We can also define a monadic version of filter (normally accessible via Control.Monad).

---

This enables us to define a "power set"

This basically says: filter each item based on a truth table (remember: the list
monad explores all possibilities).

λ> filterM (\_ -> [True, False]) [1,2,3]
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]


Truth table visualization:
λ> mapM_ print $ pure (,,) <*> [1,0] <*> [1,0] <*> [1,0]
(1,1,1)
(1,1,0)
(1,0,1)
(1,0,0)
(0,1,1)
(0,1,0)
(0,0,1)
(0,0,0)

Each item is kept per the above "truth table":
λ> mapM_ print $ filterM (\_ -> [True,False]) [1,2,3]
[1,2,3]
[1,2]
[1,3]
[1]
[2,3]
[2]
[3]
[]


Also take note of:

λ> mapM_ print $ Control.Monad.replicateM 3 [1,0]
[1,1,1]
[1,1,0]
[1,0,1]
[1,0,0]
[0,1,1]
[0,1,0]
[0,0,1]
[0,0,0]

And:

λ> mapM_ print $ sequenceA $ replicate 3 [1,0]
[1,1,1]
[1,1,0]
[1,0,1]
[1,0,0]
[0,1,1]
[0,1,0]
[0,0,1]
[0,0,0]


And:

λ> let list = [1,2,3] in let masks = sequenceA $ replicate (length list) [True,False] in map (\mask -> map fst $ filter snd $ zip list mask) masks
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]

-}
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
filterM _ []     = return []
filterM f (x:xs) = do
    b  <- f x
    ys <- filterM f xs
    if b then
        return (x:ys)
    else
        return ys


everyNthA :: Int -> [a] -> [a]
everyNthA n =
    map snd . filter (\(idx,_) -> idx `mod` n == 0) . zip [0..]


{-

If you somehow needed to track "how far" the cursor advanced...

λ> app (everyNthB 7 [0..30]) 0
([0,7,14,21,28],31)

-}
everyNthB :: Int -> [a] -> ST [a]
everyNthB n =
    filterM (\_ -> shouldKeep)
  where
    shouldKeep :: ST Bool
    shouldKeep =
        MkST
            (\s ->
                ( s `mod` n == 0
                , s + 1
                )
            )


{-

RECAP
=====

So, to sum up, Applicative for lists is implemented in terms of Cartesian
products.

The Monad instance for lists follows, but what's the difference again? The
difference is that the next computation can rely on the previous value, which
would be impossible with Applicative alone.


λ> (,) <$> [1,2,3] <*> [7,8,9]
[(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9)]

λ> do { x <- [1,2,3]; y <- [x, 8,9]; return (x,y) }
[(1,1),(1,8),(1,9),(2,2),(2,8),(2,9),(3,3),(3,8),(3,9)]

-}


{-

Normally accessible via Control.Monad

λ> join [[1,2,3], [4,5,6]]
[1,2,3,4,5,6]

λ> join (Just (Just 1))
Just 1

-}
join :: Monad m => m (m a) -> m a
join mma = do
    ma <- mma
    ma



{-

MONAD LAWS

Law 1
-----

return x >>= f   ≡   f x

Example:

λ> return 'a' >>= Just . succ
Just 'b'

λ> Just . succ $ 'a'
Just 'b'


Law 2
-----

mx >>= return   ≡   mx

Example:

λ> Just 1 >>= return
Just 1


Law 3
-----

(mx >>= f) >>= g   ≡   mx >>= (\x -> (f x >>= g))

Example:


λ> (Just 'a' >>= Just . succ) >>= Just . succ
Just 'c'

λ> Just 'a' >>= (\x -> (Just . succ) x >>= Just . succ)
Just 'c'

-}
